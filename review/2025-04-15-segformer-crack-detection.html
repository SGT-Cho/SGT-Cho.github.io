<!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SegFormer를 활용한 균열 감지 세그멘테이션 | Minjae's Life & Review Blog</title>
  
  <!-- Meta tags for SEO and social sharing -->
  <meta name="description" content="SegFormer 모델을 활용하여 이미지에서 균열을 감지하는 세그멘테이션 프로젝트의 구현 과정과 경험 공유">
  <meta name="keywords" content="SegFormer, 세그멘테이션, 균열 감지, 딥러닝, AI, 컴퓨터비전">
  <meta name="author" content="Minjae Cho">
  
  <!-- Open Graph meta tags for social sharing -->
  <meta property="og:title" content="SegFormer를 활용한 균열 감지 세그멘테이션 | Minjae's Life & Review Blog">
  <meta property="og:description" content="SegFormer 모델을 활용하여 이미지에서 균열을 감지하는 세그멘테이션 프로젝트의 구현 과정과 경험 공유">
  <meta property="og:image" content="https://sgt-cho.github.io/assets/images/portfolio/crack.png">
  <meta property="og:url" content="https://sgt-cho.github.io/review/2025-04-15-segformer-crack-detection.html">
  <meta property="og:type" content="article">
  
  <!-- Twitter card meta tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="SegFormer를 활용한 균열 감지 세그멘테이션">
  <meta name="twitter:description" content="SegFormer 모델을 활용하여 이미지에서 균열을 감지하는 세그멘테이션 프로젝트의 구현 과정과 경험 공유">
  <meta name="twitter:image" content="https://sgt-cho.github.io/assets/images/portfolio/crack.png">
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  
  <!-- Stylesheets -->
  <link rel="stylesheet" href="/css/style.css">
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="/assets/images/minjae.png">
  
  <!-- Web App Manifest -->
  <link rel="manifest" href="/manifest.json">
</head>
<body>
  <!-- 
    title: SegFormer를 활용한 균열 감지 세그멘테이션
    date: 2025-04-15
    category: review
    tags: AI, 세그멘테이션, SegFormer, 딥러닝, 컴퓨터비전
    teaser: SegFormer 모델을 활용하여 이미지에서 균열을 감지하는 세그멘테이션 프로젝트의 구현 과정과 경험 공유
    thumbnail: crack.png
    readtime: 5
  -->
  
  <!-- Header/Navigation -->
  <header>
    <nav>
      <a href="/" class="nav-logo">
        <img src="/assets/images/minjae.png" alt="Minjae Cho">
        <span>Minjae Cho</span>
      </a>
      
      <div class="nav-links">
        <a href="/life/">Life</a>
        <a href="/review/" class="active">Review</a>
        <a href="/portfolio/">Portfolio</a>
        <a href="/archive/">Archive</a>
        <a href="/about/">About</a>
      </div>
      
      <div class="hamburger" aria-label="메뉴 열기" tabindex="0">
        <span></span>
        <span></span>
        <span></span>
      </div>
    </nav>
  </header>
  
  <!-- Post Content -->
  <article class="post">
    <div class="container">
      <h1>SegFormer를 활용한 균열 감지 세그멘테이션</h1>
      
      <div class="meta">
        <div>
          <svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
          </svg>
          April 15, 2025
        </div>
        
        <div>
          <svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          5 min read
        </div>
        
        <div>
          <svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
          </svg>
          <a href="/review/">Review</a>
        </div>
      </div>
      
      <div class="post-tags">
        <a href="/tags/AI/" class="post-tag">AI</a>
        <a href="/tags/세그멘테이션/" class="post-tag">세그멘테이션</a>
        <a href="/tags/SegFormer/" class="post-tag">SegFormer</a>
        <a href="/tags/딥러닝/" class="post-tag">딥러닝</a>
        <a href="/tags/컴퓨터비전/" class="post-tag">컴퓨터비전</a>
      </div>
      
      <div class="post-content">
        <p>오늘은 SegFormer 모델을 활용하여 균열 감지를 위한 세그멘테이션 작업을 진행했습니다. 프로젝트의 주요 목표는 다양한 이미지에서 균열을 정확히 탐지하는 모델을 학습시키는 것이었으며, 이를 위해 SegFormer라는 세그멘테이션 모델을 사용했습니다. 이번 프로젝트에서 사용한 기술과 참고할 만한 내용들을 정리해보겠습니다.</p>

        <img src="/assets/images/portfolio/crack.png" alt="균열 감지 세그멘테이션 예시" class="post-image">
        
        <h2>SegFormer 모델 개요</h2>
        
        <p>SegFormer는 최근 각광받고 있는 세그멘테이션 모델로, 단순하면서도 효율적인 성능을 보여줍니다. 이번 작업에서는 간단한 U-Net 구조와 유사하게 SegFormer를 구현하여 균열 감지 문제에 적용해 보았습니다. 기본적으로 Encoder-Decoder 형태로 구성된 이 모델은 다음과 같은 주요 구성 요소를 포함합니다:</p>
        
        <ul>
          <li><strong>Encoder</strong>: 이미지에서 특징을 추출하는 역할로, 컨볼루션 계층과 ReLU 활성화 함수를 사용하여 구성했습니다.</li>
          <li><strong>Decoder</strong>: Encoder에서 추출한 특징을 바탕으로 원본 이미지의 해상도로 복원하여 각 픽셀의 클래스를 예측하는 역할을 합니다.</li>
        </ul>
        
        <h2>데이터 전처리와 마스크 생성</h2>
        
        <p>특히 이번 프로젝트에서는 레이블 데이터가 JSON 파일로 주어졌고, 이 JSON 파일에서 균열 정보를 기반으로 마스크 이미지를 생성하는 과정을 거쳤습니다. 이를 위해 다음과 같은 단계를 진행했습니다:</p>
        
        <ol>
          <li><strong>JSON 파일 파싱 및 마스크 생성</strong>: 각 JSON 파일에는 'annotations'라는 키가 있으며, 이 안에 균열 정보가 포함되어 있습니다. 'polygon' 또는 'polyline' 형태로 저장된 좌표를 이용하여 균열이 있는 영역만 마스크 이미지로 변환했습니다.</li>
          <li><strong>마스크 이미지 생성 후 저장</strong>: 균열이 있는 경우에만 마스크 이미지를 생성하고, 빈 마스크는 생성하지 않도록 하여 효율적으로 데이터를 관리했습니다.</li>
          <li><strong>CSV 파일 생성</strong>: 균열이 있는 이미지 파일명을 따로 CSV 파일에 저장하여 후속 작업에서 참고할 수 있도록 했습니다.</li>
        </ol>
        
        <h3>JSON에서 마스크로 변환하는 코드 예시</h3>
        
        <pre><code>import json
import numpy as np
import cv2
from pathlib import Path

def create_mask_from_json(json_path, image_shape):
    with open(json_path, 'r') as f:
        data = json.load(f)
    
    mask = np.zeros(image_shape[:2], dtype=np.uint8)
    
    for annotation in data['annotations']:
        if 'polygon' in annotation:
            points = np.array(annotation['polygon'], dtype=np.int32)
            cv2.fillPoly(mask, [points], 255)
        elif 'polyline' in annotation:
            points = np.array(annotation['polyline'], dtype=np.int32)
            cv2.polylines(mask, [points], False, 255, thickness=5)
    
    return mask</code></pre>
        
        <h2>모델 학습</h2>
        
        <p>SegFormer 모델 학습은 아래의 과정으로 진행되었습니다:</p>
        
        <ul>
          <li><strong>데이터셋 로딩</strong>: 이미지와 마스크를 불러와 학습에 사용할 수 있도록 데이터셋을 정의했습니다. 이미지와 마스크 간 개수가 일치하지 않는 경우 경고를 출력하고, 일치하는 경우에만 학습에 사용하도록 했습니다.</li>
          <li><strong>손실 함수 및 옵티마이저</strong>: CrossEntropyLoss를 사용하여 모델의 예측 결과와 실제 마스크 간의 손실을 계산하고, AdamW 옵티마이저를 사용하여 학습을 진행했습니다.</li>
          <li><strong>학습 루프</strong>: 모델 학습 중 매 에포크마다 학습 손실과 검증 손실을 출력하여 모델 성능을 모니터링했습니다. 또한 검증 손실이 개선될 경우 모델을 저장했습니다.</li>
        </ul>
        
        <h3>간단한 SegFormer 구현 예시</h3>
        
        <pre><code>import torch
import torch.nn as nn
import torch.nn.functional as F

class SimpleSegFormer(nn.Module):
    def __init__(self, in_channels=3, out_channels=1):
        super(SimpleSegFormer, self).__init__()
        
        # Encoder
        self.enc1 = nn.Sequential(
            nn.Conv2d(in_channels, 64, kernel_size=3, padding=1),
            nn.ReLU(inplace=True)
        )
        self.enc2 = nn.Sequential(
            nn.MaxPool2d(kernel_size=2, stride=2),
            nn.Conv2d(64, 128, kernel_size=3, padding=1),
            nn.ReLU(inplace=True)
        )
        self.enc3 = nn.Sequential(
            nn.MaxPool2d(kernel_size=2, stride=2),
            nn.Conv2d(128, 256, kernel_size=3, padding=1),
            nn.ReLU(inplace=True)
        )
        
        # Decoder
        self.dec3 = nn.Sequential(
            nn.Conv2d(256, 128, kernel_size=3, padding=1),
            nn.ReLU(inplace=True),
            nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)
        )
        self.dec2 = nn.Sequential(
            nn.Conv2d(128, 64, kernel_size=3, padding=1),
            nn.ReLU(inplace=True),
            nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)
        )
        self.dec1 = nn.Conv2d(64, out_channels, kernel_size=1)
        
    def forward(self, x):
        # Encoder
        enc1 = self.enc1(x)
        enc2 = self.enc2(enc1)
        enc3 = self.enc3(enc2)
        
        # Decoder
        dec3 = self.dec3(enc3)
        dec2 = self.dec2(dec3)
        outputs = self.dec1(dec2)
        
        return outputs</code></pre>
        
        <h2>오늘의 성과와 느낀 점</h2>
        
        <ul>
          <li><strong>JSON 기반 마스크 생성</strong>: 레이블링 데이터에서 유효한 정보를 추출하고 이를 마스크로 변환하는 과정이 특히 흥미로웠습니다. 자동으로 마스크를 생성하여 균열이 있는 이미지만 선별할 수 있었던 점이 효율적이었습니다.</li>
          <li><strong>모델 성능 개선 가능성</strong>: 아직 초기 학습 단계라서 모델 성능이 완벽하지는 않지만, 데이터 전처리의 중요성을 다시 한번 느꼈습니다. 특히 균열이 없는 이미지를 잘 걸러내는 것이 학습 효율을 높이는 데 도움이 될 것으로 보입니다.</li>
        </ul>
        
        <h2>참고할 만한 내용</h2>
        
        <ul>
          <li><strong>데이터 전처리 효율화</strong>: JSON 파일에서 필요 없는 데이터를 걸러내는 방식으로 데이터셋을 효율화하는 작업은 이후 다른 프로젝트에서도 사용할 수 있을 것 같습니다. 특히 대용량 데이터에서 불필요한 연산을 줄이는 것이 중요했습니다.</li>
          <li><strong>SegFormer 구조 변경</strong>: SegFormer의 기본 구조를 간단하게 구현했지만, 추후 Transformer 기반으로 encoder를 개선하는 것도 고려해볼 만합니다.</li>
        </ul>
        
        <h2>다음 단계</h2>
        
        <ul>
          <li><strong>모델 구조 개선</strong>: U-Net과 유사한 단순한 구조에서 벗어나 SegFormer의 원래 구조에 가까운 Transformer 기반의 인코더로 업그레이드할 계획입니다.</li>
          <li><strong>데이터셋 추가 확보 및 증강</strong>: 현재 사용하고 있는 데이터셋 외에도 추가적인 균열 데이터를 확보하고, 데이터 증강 기법을 적용하여 모델의 일반화 성능을 높일 예정입니다.</li>
        </ul>
        
        <p>오늘 진행한 프로젝트는 균열 탐지 문제를 다루는 데 있어 데이터 전처리의 중요성과 SegFormer 모델의 가능성을 보여주는 좋은 경험이었습니다. 컴퓨터 비전 분야에서 세그멘테이션은 단순한 분류 문제보다 더 많은 정보를 제공할 수 있으며, 특히 균열과 같은 시각적 특징을 정확히 탐지하는 데 큰 장점이 있습니다. 앞으로도 이 모델을 지속적으로 개선하여 더 나은 결과를 얻을 수 있도록 노력하겠습니다.</p>
      </div>
    </div>
  </article>
  
  <!-- Footer -->
  <footer>
    <div class="container">
      <p>&copy; 2025 Minjae Cho · Built with passion and code</p>
    </div>
  </footer>
  
  <!-- Scripts -->
  <script src="/js/main.js"></script>
</body>
</html>